{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-07-03T01:23:02.619221+00:00",
  "repo": "hpkewg/hpke",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOLtax86u7cOn",
      "title": "Remove Auth and AuthPSK modes",
      "url": "https://github.com/hpkewg/hpke/issues/1",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE has four modes: Base, PSK, Auth, and AuthPSK.  Auth and AuthPSK are supported by DHKEM, but no other known KEM.  And there is no known application usage of them.  So we should remove them from this updated spec.",
      "createdAt": "2025-03-20T10:06:18Z",
      "updatedAt": "2025-06-24T01:49:37Z",
      "closedAt": "2025-06-24T01:49:37Z",
      "comments": [
        {
          "author": "cfm",
          "authorAssociation": "NONE",
          "body": "For what it's worth, we plan to use the `Auth` mode in freedomofpress/securedrop-protocol#48.  We'd be happy to discuss our use-case further either here or on the mailing list.",
          "createdAt": "2025-04-18T01:40:53Z",
          "updatedAt": "2025-04-18T18:00:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cfm we have an upcoming interim meeting if you want to make a case for these ahead of that.  (Your attendance at that meeting would be helpful; this is one of the issues we plan to discuss.)",
          "createdAt": "2025-06-04T04:48:24Z",
          "updatedAt": "2025-06-04T04:48:24Z"
        },
        {
          "author": "cfm",
          "authorAssociation": "NONE",
          "body": "Thanks, @martinthomson.  I'll attend Friday's interim meeting, and there's been some discussion already in <https://mailarchive.ietf.org/arch/msg/hpke/vByRJAtCXGx9byOkV-QBln7KTBE/>.  We've also been able to confirm at least one implementer's intention to preserve these modes (cryspen/hpke-rs#83).  I'd be happy to do further outreach like this if it will help inform the working group's decision.",
          "createdAt": "2025-06-04T16:54:21Z",
          "updatedAt": "2025-06-04T16:54:21Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOOLtax86u7cxW",
      "title": "Apply Errata on RFC 9180",
      "url": "https://github.com/hpkewg/hpke/issues/2",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "RFC 9180 has had several errata filed on it:\n\n* Verified\n    * [X] https://www.rfc-editor.org/errata/eid6941\n    * [X] https://www.rfc-editor.org/errata/eid7790\n    * [x] https://www.rfc-editor.org/errata/eid7934\n    * [X] https://www.rfc-editor.org/errata/eid7937\n    * [X] https://www.rfc-editor.org/errata/eid7932\n* HFDU\n    * [X] https://www.rfc-editor.org/errata/eid7251\n    * [X] https://www.rfc-editor.org/errata/eid7933\n\nThey should be addressed in this new document.",
      "createdAt": "2025-03-20T10:07:00Z",
      "updatedAt": "2025-06-09T18:37:00Z",
      "closedAt": "2025-06-09T18:36:58Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this issue resolved?  Are there any questions you would like to float at the upcoming interim, in case the resolutions were tricky?\n\nMy own assessment is that these were all straightforward.  Virtually all were small and obvious.  We could just show the diffs briefly. Either way, we can highlight each change again at WGLC time, so that people can double check then.",
          "createdAt": "2025-06-04T04:47:29Z",
          "updatedAt": "2025-06-04T04:47:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree.  We should just merge the related PRs, and that will address this issue.",
          "createdAt": "2025-06-04T07:57:47Z",
          "updatedAt": "2025-06-04T07:57:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Related PRs have been merged.",
          "createdAt": "2025-06-09T18:36:58Z",
          "updatedAt": "2025-06-09T18:36:58Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOOLtax86u7d4w",
      "title": "Add support for non-two-stage KDFs",
      "url": "https://github.com/hpkewg/hpke/issues/3",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The KDF interface in HPKE requires discrete Extract and Expand operations.  More modern, sponge-based KDFs such as SHAKE do not have these discrete steps.  We should define a new, alternative KDF interface that can be used by KDFs of this form.",
      "createdAt": "2025-03-20T10:08:29Z",
      "updatedAt": "2025-06-09T19:38:20Z",
      "closedAt": "2025-06-09T19:38:20Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOOLtax86u7f0c",
      "title": "Define PQ ciphersuites",
      "url": "https://github.com/hpkewg/hpke/issues/4",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE needs to have ciphersuites that are resistant to attack by a quantum computer.  We should define a set of PQ ciphersuites that address common use cases:\n\n* [ ] Hybrid: DHKEM(X25519) + ML-KEM-768\n* [ ] Hybrid: DHKEM(P-256) + ML-KEM-768\n* [ ] Hybrid: DHKEM(P-384) + ML-KEM-1024\n* [ ] Pre PQ: ML-KEM-768\n* [ ] Pre PQ: ML-KEM-1024",
      "createdAt": "2025-03-20T10:11:02Z",
      "updatedAt": "2025-03-25T01:33:16Z",
      "closedAt": "2025-03-23T21:07:04Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because this should be a separate document.",
          "createdAt": "2025-03-23T21:07:04Z",
          "updatedAt": "2025-03-23T21:07:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "We *could* add that document to this repository.",
          "createdAt": "2025-03-24T06:28:07Z",
          "updatedAt": "2025-03-24T06:28:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Repos are cheap, and the tooling seems oriented toward one draft per repo.",
          "createdAt": "2025-03-24T17:38:56Z",
          "updatedAt": "2025-03-24T17:38:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Agree with the former, but I'll object to the latter.  The tooling works perfectly well with multiple drafts in a repo.",
          "createdAt": "2025-03-25T01:33:14Z",
          "updatedAt": "2025-03-25T01:33:14Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOOLtax86u8Wfz",
      "title": "IANA registry takeover",
      "url": "https://github.com/hpkewg/hpke/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We can make this an IETF registry",
      "createdAt": "2025-03-20T11:13:35Z",
      "updatedAt": "2025-06-09T19:42:35Z",
      "closedAt": "2025-06-09T19:42:35Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there's any action to be taken here in terms of \"taking control\".  The registries already exist, and have experts assigned.\n\nThat said, we should update the IANA considerations to remove them and reflect that the registries already exist.",
          "createdAt": "2025-03-23T21:10:21Z",
          "updatedAt": "2025-03-23T21:10:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like there isn't a change controller listed for these registries.  Should we update that to point to the IETF?",
          "createdAt": "2025-03-24T06:28:43Z",
          "updatedAt": "2025-03-24T06:28:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the notion of a change controller is salient here.  For example, there is no change controller listed for the TLS registries; no mention at all in RFC 8447.  All of the registries here are Specification Required, and the provisions for change control in RFC 8126 don't advise having a change controller for Specification Required registries.",
          "createdAt": "2025-03-24T17:23:26Z",
          "updatedAt": "2025-03-24T17:23:26Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOOLtax863HW-M",
      "title": "IANA: Recommended column?",
      "url": "https://github.com/hpkewg/hpke/issues/17",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After #5, @sftcd asks the question about whether the group sees value in a Recommended column, like those in RFC 8447([bis](https://datatracker.ietf.org/doc/html/draft-ietf-tls-rfc8447bis-09)).\n\nAn argument for this is that we might split the difference between accepted and non-existent.  For those who feel like the pure PQ modes (like the existing codepoints 0x0040-0x0042) are unacceptable, this would provide some encouragement to use the PQ/T modes instead.",
      "createdAt": "2025-05-19T00:16:36Z",
      "updatedAt": "2025-06-24T15:34:52Z",
      "closedAt": "2025-06-24T15:34:52Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would strongly prefer not to add this column.  My impression from the experience with RFC 8447 is that these Recommended columns are all cost and no benefit.  Working groups spend time arguing over the values, and then no implementor pays attention.  This is a point on which letting the market sort things out has worked fine; most people use modern algorithms, and those who don't wouldn't be persuaded by a Y in a registry.\n\nHPKE is an even more restricted case than TLS.  HPKE tends to get embedded in other protocols, like MLS or ECH.  So even if you believe Recommended improves interoperability in general, there's even less need for it at the HPKE level, since it can get solved at higher layers.",
          "createdAt": "2025-05-19T00:44:15Z",
          "updatedAt": "2025-05-19T00:44:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "> I would strongly prefer not to add this column.\n\nI'm neutral as to whether we use that or some other mechanism.\n\n> My impression from the experience with RFC 8447 is that these Recommended columns are all cost and no benefit. Working groups spend time arguing over the values, and then no implementor pays attention. \n\nThe above seems like something where someone could gather data - has anyone? (Not to my knowledge.)\n\n> This is a point on which letting the market sort things out has worked fine; most people use modern algorithms, and those who don't wouldn't be persuaded by a Y in a registry.\n> \n> HPKE is an even more restricted case than TLS. HPKE tends to get embedded in other protocols, like MLS or ECH. So even if you believe Recommended improves interoperability in general, there's even less need for it at the HPKE level, since it can get solved at higher layers.\n\nI'm not sure above MLS, but ECH (section 9) just says that unless there's some other profile somewhere you MUST implement x25519+hkdf-sha256, hkdf-sha256, aes-128-gcm. That's been mostly pretty ok 'till now as there weren't that many non-crazy combinations (though there are some implementations that don't allow all combinations of the kems, kdfs and aeads that they do support), but adding all these PQ options can potentially make interop a good bit worse, if people start using their favourites without more guidance. \n\nAgain, I don't mind how we tell people to not bother with mlkem-512 (assuming that's what we agree), but there are going to be so many combinations we really should provide some guidance, either as part of this work, or via updates to ECH/MLS (but that last seems quite heavyweight).",
          "createdAt": "2025-05-19T16:51:15Z",
          "updatedAt": "2025-05-19T16:51:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd - What would you think about using the Security Considerations for this instead of registry text?  There's probably pretty broad agreement that:\n\n* Hybrids are more conservative than pure PQ, but we include pure PQ because some organizations need it\n* ML-KEM-512 should be avoided, but we include it for completeness",
          "createdAt": "2025-05-20T00:25:02Z",
          "updatedAt": "2025-05-20T00:25:02Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "> [@sftcd](https://github.com/sftcd) - What would you think about using the Security Considerations for this instead of registry text? \n\nI've no objection to trying that, but wonder whether we can craft good text to guide DEs for future assignment requests given the zoo of PQ algs. \n\n> There's probably pretty broad agreement that:\n> \n> * Hybrids are more conservative than pure PQ, but we include pure PQ because some organizations need it\n\nAs an aside: I've not gotten the (technical) \"need\" bit of that but yes people express that desire.\n\n> * ML-KEM-512 should be avoided, but we include it for completeness\n\nAgain, I wonder if we can craft (security considerations) text that works for other PQ combinations we might dislike, but no harm trying. I'd say this is maybe a thing to not try decide too early, and we may be better waiting to see who implements what, for what, with what quirks, and then figure out how best to document things.\n\n",
          "createdAt": "2025-05-20T01:03:06Z",
          "updatedAt": "2025-05-20T01:03:06Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "NONE",
          "body": "JOSE, COSE, and TLS all have a Recommended column for algorithms.  The purpose of this is to guide implementations to implement a common set of algorithm choices to improve interoperability.\n\nI believe we should do likewise.",
          "createdAt": "2025-06-06T17:00:57Z",
          "updatedAt": "2025-06-06T17:00:57Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "+1 to having such a column, and similar to TLS having PQ-only KEMs it discouraged or not recommended to nuge general purpose library implementors to not expose/implement indiscriminately. The (in my impression) consensus on PQ-only KEMs versus PQ/T KEMs *at this time* is that PQ-only is riskier while having basically negligible performance advantages. Having implementors consider them to be on the same level and implement all for compatibility is, at this time, is putting end users of implementations and at risk.\nI also said in the interim that I think the PQ-only KEMs should at least be in another document as separate code points. ",
          "createdAt": "2025-06-06T17:03:42Z",
          "updatedAt": "2025-06-06T17:03:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I have never heard an implementer say that a Recommended column was a significant factor in whether they did or did not implement an algorithm.  These columns cause massive amounts of debate, with negligible impact on deployed reality.  No benefit to security or interoperability.  They're not worth the effort.\n\nI also support the point @yaroslavros made on the call, that HPKE is most commonly used as a component -- in TLS, MLS, COSE, or JOSE.  If you think that Recommended matters, those registries have you covered.  In terms of more heat than light, if HPKE also has a Recommended column, it will attract the union of the controversies from all those groups, since if HPKE says Recommended=N, you're going to have a harder time justifying Recommended=Y in the TLS registry.",
          "createdAt": "2025-06-06T17:44:51Z",
          "updatedAt": "2025-06-06T17:44:51Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "> I have never heard an implementer say that a Recommended column was a significant factor in whether they did or did not implement an algorithm.\n\nHave you heard about customers putting it in purchasing reqs?  I have :)",
          "createdAt": "2025-06-06T17:56:31Z",
          "updatedAt": "2025-06-06T17:56:31Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> In terms of more heat than light, if HPKE also has a Recommended column, it will attract the union of the controversies from all those groups, since if HPKE says Recommended=N, you're going to have a harder time justifying Recommended=Y in the TLS registry.\n\nAnd this would be bad how if it is a good decision to have it as N?",
          "createdAt": "2025-06-06T18:19:22Z",
          "updatedAt": "2025-06-06T18:19:22Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Normally I am in favor of the Recommended column, but in this case I agree with Richard, because, as he says, HPKE is really a method of packaging up algorithms and providing them to protocols. Thus, I think it would be better for those protocols to make the Recommended decision. This is particularly true for protocols like TLS which may use HPKE (in the case of TLS, in ECH) but also have the algorithms exposed directly to the protocol. It would be a weird outcome to have TLS simultaneously recommend algorithm X for key establishment but not for use in HPKE, but also weird to have it mark an algorithm Recommended=Y when HPKE marks it recommended=N.",
          "createdAt": "2025-06-06T19:03:46Z",
          "updatedAt": "2025-06-06T19:03:46Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "> > In terms of more heat than light, if HPKE also has a Recommended column, it will attract the union of the controversies from all those groups, since if HPKE says Recommended=N, you're going to have a harder time justifying Recommended=Y in the TLS registry.\n> \n> And this would be bad how if it is a good decision to have it as N?\n\nThis assumes that somehow we have some unambiguous way of defining a \"good decision\". Rather, people have differing opinions and different groups of those people -- even if they may have a common subset -- may reach different conclusions.",
          "createdAt": "2025-06-06T19:06:36Z",
          "updatedAt": "2025-06-06T19:06:36Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I find ekr's reasoning in https://github.com/hpkewg/hpke/issues/17#issuecomment-2950272234 compelling. I'd like to see text like that in the \"iana actions\" section.",
          "createdAt": "2025-06-06T19:09:32Z",
          "updatedAt": "2025-06-06T19:09:32Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "NONE",
          "body": "I could live with the outcome of providing the rationale for why we don't have a Recommended column in the specification.",
          "createdAt": "2025-06-06T19:28:37Z",
          "updatedAt": "2025-06-06T19:28:37Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> > > In terms of more heat than light, if HPKE also has a Recommended column, it will attract the union of the controversies from all those groups, since if HPKE says Recommended=N, you're going to have a harder time justifying Recommended=Y in the TLS registry.\n> > \n> > \n> > And this would be bad how if it is a good decision to have it as N?\n> \n> This assumes that somehow we have some unambiguous way of defining a \"good decision\". Rather, people have differing opinions and different groups of those people -- even if they may have a common subset -- may reach different conclusions.\n\nAre you saying that in order to not inconvenience other WGs a WG should in doubt go with what is more compatible, instead of what would be the better choice? I am not sure that sits right with me. How can I trust as an implementor using HPKE that the algorithms at my disposal are of similar quality, or even safe? They may just be there for legacy reasons but actually highly discouraged from use. That should be very transparent and obvious.",
          "createdAt": "2025-06-06T19:46:15Z",
          "updatedAt": "2025-06-06T19:46:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "> Are you saying that in order to not inconvenience other WGs a WG should in doubt go with what is more compatible, instead of what would be the better choice?\n\nNo, I'm not saying that, nor did my comment say anything like that.\n\n\n> I am not sure that sits right with me. How can I trust as an implementor using HPKE that the algorithms at my disposal are of similar quality, or even safe? They may just be there for legacy reasons but actually highly discouraged from use. That should be very transparent and obvious.\n\nWhat I'm saying, as above, is that \"an implementor using HPKE\" is most likely using it in some other protocol and should refer to that protocol for what is recommended.",
          "createdAt": "2025-06-06T19:48:37Z",
          "updatedAt": "2025-06-06T19:48:37Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> Normally I am in favor of the Recommended column, but in this case I agree with Richard, because, as he says, HPKE is really a method of packaging up algorithms and providing them to protocols. Thus, I think it would be better for those protocols to make the Recommended decision. This is particularly true for protocols like TLS which may use HPKE (in the case of TLS, in ECH) but also have the algorithms exposed directly to the protocol. It would be a weird outcome to have TLS simultaneously recommend algorithm X for key establishment but not for use in HPKE, but also weird to have it mark an algorithm Recommended=Y when HPKE marks it recommended=N.\n\nYes and no. This percieved wierdness is on one hand a result from the decision that was made against the same objections brought here. Saying that \"well we have decided that over there, so we are going to have to follow\" is basically what everybody fearing the risk of PQ-only KEMs in TLS ultimately has: Normalization of its use and silencing of voices through this act that raise the concerns using exactly this argument: \"We are going to use it because its in TLS, what can possibly go wrong, right?\"\n\nRegarding the \"wierdness\" of having different requirements on the KEM for different things: TLS Key Agreement IS a completely different beast. It would not be odd at all if the primitives are different for the ECH. For example, having a secure generic combiner for the PQ and T KEMs is of less concern in TLS (not ECH) than HPKE because of the transcript hashes.\nBut HPKE would be used for ECH. So there, it would not be odd at all if PQ and T is combined differently with different requirements for good reasons.",
          "createdAt": "2025-06-06T20:07:12Z",
          "updatedAt": "2025-06-06T20:07:12Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "> Yes and no. This percieved wierdness is on one hand a result from the decision that was made against the same objections brought here. Saying that \"well we have decided that over there, so we are going to have to follow\" is basically what everybody fearing the risk of PQ-only KEMs in TLS ultimately has: Normalization of its use and silencing of voices through this act that raise the concerns using exactly this argument: \"We are going to use it because its in TLS, what can possibly go wrong, right?\"\n\nThis comment also seems to be responding to some point I am not making, which has nothing to do with doing something in HPKE purely because it's in TLS. What's at stake in *this* issue is merely whether there is a column in the IANA registry for HPKE about whether it's Recommended. The lack of such a column does not in any way preclude you from opposing the use of a particular algorithm in some other protocol that is used in TLS (or whatever).\n\n\n> Regarding the \"wierdness\" of having different requirements on the KEM for different things: TLS Key Agreement IS a completely different beast. It would not be odd at all if the primitives are different for the ECH. For example, having a secure generic combiner for the PQ and T KEMs is of less concern in TLS (not ECH) than HPKE because of the transcript hashes. But HPKE would be used for ECH. So there, it would not be odd at all if PQ and T is combined differently with different requirements for good reasons.\n\nThis too is not the question at hand. It does in fact seem likely that PQ and T will be defined differently in ECH and TLS. However, if TLS recommends the use of algorithm X in KEX *and* X is specified in HPKE, but there is some technical issue that means that X can't be safely used for ECH, that seems like it's a sign of something severely wrong with the X-for-HPKE binding.\n\n\n\n\n\n\n\n",
          "createdAt": "2025-06-06T20:34:43Z",
          "updatedAt": "2025-06-06T20:34:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering this resolved via https://mailarchive.ietf.org/arch/msg/hpke/o6FFVc9VcCWFNJZXUE9TrU3ob5o/",
          "createdAt": "2025-06-24T15:34:52Z",
          "updatedAt": "2025-06-24T15:34:52Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOOLtax866SKHS",
      "title": "Add a \"comments\" column to IANA registries",
      "url": "https://github.com/hpkewg/hpke/issues/20",
      "state": "CLOSED",
      "author": "richsalz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-06T16:52:28Z",
      "updatedAt": "2025-06-24T15:35:05Z",
      "closedAt": "2025-06-24T15:35:05Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Without more detail, it's hard to discern intent, but this seems like a bad idea.",
          "createdAt": "2025-06-06T17:01:14Z",
          "updatedAt": "2025-06-06T17:01:14Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Why is it bad?  Adding a free-text field *now* before you\u2019ll need it seems like future-proofing to me.\r\n",
          "createdAt": "2025-06-06T17:34:57Z",
          "updatedAt": "2025-06-06T17:34:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As the saying goes, YAGNI",
          "createdAt": "2025-06-06T17:36:59Z",
          "updatedAt": "2025-06-06T17:36:59Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "DHCPv6 has a \u201cmnemonic\u201d column.\r\nmailparameters Registered States has a \u201cUse\u201d column.\r\nMulticast email SMTP Extensions has a Note column.\r\n\r\nI stopped looking.\r\n\r\n\r\n",
          "createdAt": "2025-06-06T17:55:19Z",
          "updatedAt": "2025-06-06T17:55:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If there's WG consensus to add a comment to one or more algorithms, we can add the column.  But there's no point to adding it without a need.  It's not futureproofing, because whatever thing makes the comment can also add the column.",
          "createdAt": "2025-06-06T17:58:11Z",
          "updatedAt": "2025-06-06T17:58:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering this resolved via https://mailarchive.ietf.org/arch/msg/hpke/o6FFVc9VcCWFNJZXUE9TrU3ob5o/",
          "createdAt": "2025-06-24T15:35:05Z",
          "updatedAt": "2025-06-24T15:35:05Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOOLtax869HAsL",
      "title": "Suites vs. Independent Algs",
      "url": "https://github.com/hpkewg/hpke/issues/23",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/hpke/Oio9iAVhSB0mka4r3aU7IcjhYNc/",
      "createdAt": "2025-06-24T17:20:58Z",
      "updatedAt": "2025-06-30T22:20:37Z",
      "closedAt": "2025-06-30T22:20:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "https://mailarchive.ietf.org/arch/msg/hpke/BDKsmqSb9cDPUsb-VZlRu6FZMW0/",
          "createdAt": "2025-06-30T22:20:37Z",
          "updatedAt": "2025-06-30T22:20:37Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOOLtax86-Sf7L",
      "title": "Missing a section describing changes from RFC 9180",
      "url": "https://github.com/hpkewg/hpke/issues/25",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-01T13:33:09Z",
      "updatedAt": "2025-07-01T13:33:09Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 6,
      "id": "PR_kwDOOLtax86Pv9d7",
      "title": "Fix Erratum 6941",
      "url": "https://github.com/hpkewg/hpke/pull/6",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid6941",
      "createdAt": "2025-03-23T04:54:18Z",
      "updatedAt": "2025-06-09T17:51:06Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid6941",
      "headRefOid": "814c874aff01d488fded1a050978f5ad45ea54c7",
      "closedAt": "2025-06-09T17:51:00Z",
      "mergedAt": "2025-06-09T17:51:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ca65af15ba0597003d91e66e55a77e7ceaabd7a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he3Hu",
          "commit": {
            "abbreviatedOid": "8e0ba1f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T06:16:36Z",
          "updatedAt": "2025-03-24T06:16:38Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "The rewrapping makes the change look bigger than it is.",
              "createdAt": "2025-03-24T06:16:36Z",
              "updatedAt": "2025-03-24T06:16:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOOLtax86Pv9fP",
      "title": "Fix Erratum 7251",
      "url": "https://github.com/hpkewg/hpke/pull/7",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7251",
      "createdAt": "2025-03-23T04:54:44Z",
      "updatedAt": "2025-06-09T17:51:24Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7251",
      "headRefOid": "59ca2d6cbdc267e0d1e25e435adf1ea77fcd9c8a",
      "closedAt": "2025-06-09T17:51:22Z",
      "mergedAt": "2025-06-09T17:51:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "32f31d741695a2cbd8ce755a1e7c6ab625cfbe82"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he5Vq",
          "commit": {
            "abbreviatedOid": "3bd7747"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-24T06:22:30Z",
          "updatedAt": "2025-03-24T06:22:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This one took me an age to understand.  The section is talking about input length, with a table of input lengths that contains very large numbers, but what this refers to is the length of the prefix label.\r\n\r\n```suggestion\r\nThe RECOMMENDED limit for these prefixes is 66 bytes. This would enable\r\n```\r\n\r\nDo the numbers in the table need to be tweaked to match?",
              "createdAt": "2025-03-24T06:22:30Z",
              "updatedAt": "2025-03-24T06:22:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86iDHwY",
          "commit": {
            "abbreviatedOid": "3bd7747"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-26T22:13:27Z",
          "updatedAt": "2025-03-26T22:13:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "No, I think this is about the values, not the prefixes.  In the sense that, while the bounds above are huge, in practice, you basically never need something more than 64 bytes.  (64 bytes should be enough for anyone!)  I'll try rewording to clarify this.",
              "createdAt": "2025-03-26T22:13:27Z",
              "updatedAt": "2025-03-26T22:13:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86iDwBQ",
          "commit": {
            "abbreviatedOid": "f31aad0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Much better, thanks.",
          "createdAt": "2025-03-27T00:19:29Z",
          "updatedAt": "2025-03-27T00:19:36Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\ndocument, the limit would be 66 bytes, which is the `Nsk` value for DHKEM(P-521,\r\n```",
              "createdAt": "2025-03-27T00:19:29Z",
              "updatedAt": "2025-03-27T00:19:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "PR_kwDOOLtax86Pv9hP",
      "title": "Fix Erratum 7932",
      "url": "https://github.com/hpkewg/hpke/pull/8",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7932",
      "createdAt": "2025-03-23T04:55:18Z",
      "updatedAt": "2025-06-09T17:51:39Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7932",
      "headRefOid": "41852e64d96e84da4159f605c365f6c524913709",
      "closedAt": "2025-06-09T17:51:37Z",
      "mergedAt": "2025-06-09T17:51:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c59b99cf523e913a084f61d737672aaa3703d5a0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he5qV",
          "commit": {
            "abbreviatedOid": "90bfb59"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T06:23:16Z",
          "updatedAt": "2025-03-24T06:23:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOOLtax86Pv9k1",
      "title": "Fix Erratum 7790",
      "url": "https://github.com/hpkewg/hpke/pull/9",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7790",
      "createdAt": "2025-03-23T04:56:17Z",
      "updatedAt": "2025-06-09T17:51:53Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7790",
      "headRefOid": "5202577c9b47ebf1e3b6af33d3438ac918d2916a",
      "closedAt": "2025-06-09T17:51:51Z",
      "mergedAt": "2025-06-09T17:51:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8bdcf5a2e0517eba9e79a9fc29a04ac1544aa234"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he599",
          "commit": {
            "abbreviatedOid": "23fd83e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T06:24:09Z",
          "updatedAt": "2025-03-24T06:24:13Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ninterface fulfills the notions of Outsider-CCA, Insider-CCA, and Outsider-Auth\r\n```",
              "createdAt": "2025-03-24T06:24:09Z",
              "updatedAt": "2025-03-24T06:24:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 10,
      "id": "PR_kwDOOLtax86Pv9ou",
      "title": "Fix Erratum 7933",
      "url": "https://github.com/hpkewg/hpke/pull/10",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7933",
      "createdAt": "2025-03-23T04:56:43Z",
      "updatedAt": "2025-06-09T17:52:14Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7933",
      "headRefOid": "1ae7efeb9ef3ebe99385d5780e5697572f3371ab",
      "closedAt": "2025-06-09T17:52:12Z",
      "mergedAt": "2025-06-09T17:52:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b839e40caff6a97d3113080b8094af20fe0a2353"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he7Vp",
          "commit": {
            "abbreviatedOid": "64b1036"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "You went with parameter elsewhere...",
          "createdAt": "2025-03-24T06:27:12Z",
          "updatedAt": "2025-03-24T06:27:21Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nof sender or recipient, respectively. The third parameter in the\r\n```",
              "createdAt": "2025-03-24T06:27:12Z",
              "updatedAt": "2025-03-24T06:27:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOOLtax86Pv9qL",
      "title": "Fix Erratum 7937",
      "url": "https://github.com/hpkewg/hpke/pull/11",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7937",
      "createdAt": "2025-03-23T04:57:08Z",
      "updatedAt": "2025-06-09T17:54:14Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7937",
      "headRefOid": "1d90e21712dd960fcfd79fa0faf87fa7bf44e78e",
      "closedAt": "2025-06-09T17:54:05Z",
      "mergedAt": "2025-06-09T17:54:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dba55a1b54428e26937ffe4213e8236fdc65c841"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOOLtax86Px8UV",
      "title": "Fix Erratum 7934",
      "url": "https://github.com/hpkewg/hpke/pull/12",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid7934\r\n\r\nThis PR implements the change described in the notes of erratum 7934, replacing all instances of \"field\" with \"parameter\", except where \"field\" is referring to a mathematical field.",
      "createdAt": "2025-03-23T21:04:31Z",
      "updatedAt": "2025-06-09T18:36:39Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "eid7934",
      "headRefOid": "685c3b02cbfc2233e1404cdd1c779391df71b1e7",
      "closedAt": "2025-06-09T18:36:36Z",
      "mergedAt": "2025-06-09T18:36:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5eb55d1119e90ddc2111ad12fb891a5c1721c3c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he6we",
          "commit": {
            "abbreviatedOid": "768e178"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-24T06:26:09Z",
          "updatedAt": "2025-03-24T06:26:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nused by the `LabeledExpand()` or `Expand()` functions detailed in {{base-crypto}}.\r\n```",
              "createdAt": "2025-03-24T06:26:09Z",
              "updatedAt": "2025-03-24T06:26:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOOLtax86Px9Sz",
      "title": "Update IANA considerations",
      "url": "https://github.com/hpkewg/hpke/pull/13",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The IANA registries already exist, so this document doesn't need to specify them.",
      "createdAt": "2025-03-23T21:13:20Z",
      "updatedAt": "2025-06-09T19:42:38Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "42e54f04ff8bf2eae0f3654a2ff37ef8b51247bc",
      "headRepository": "hpkewg/hpke",
      "headRefName": "iana",
      "headRefOid": "e229901f0f833a3eb90a30becb9f8bead3eefa3e",
      "closedAt": "2025-06-09T19:42:34Z",
      "mergedAt": "2025-06-09T19:42:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6f03329d4a83f96699748e1f3e8c0ebd4c3e5042"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The cross-reference to RFC 9180 is sub-optimal.  Maybe we should inline the column definitions, or even delete the algorithm definitions altogether (since they already exist in RFC 9180).",
          "createdAt": "2025-03-23T21:18:05Z",
          "updatedAt": "2025-03-23T21:18:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR wasn't explicitly discussed in the interim, but it didn't come up in the IANA discussion, so I'm assuming folks are OK with it.",
          "createdAt": "2025-06-09T19:42:29Z",
          "updatedAt": "2025-06-09T19:42:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86he8Tr",
          "commit": {
            "abbreviatedOid": "1d74848"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-24T06:29:48Z",
          "updatedAt": "2025-03-24T06:29:51Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Don't we want all of the items registered in RFC 9180 to point to this document?",
              "createdAt": "2025-03-24T06:29:48Z",
              "updatedAt": "2025-03-24T06:29:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86hmhcs",
          "commit": {
            "abbreviatedOid": "1d74848"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-03-24T17:41:17Z",
          "updatedAt": "2025-03-24T17:41:17Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah, I suppose we could do that, in which case we would want to reiterate all the definitions here.  \r\n\r\nAs a side note, this document should also obsolete RFC 9180.",
              "createdAt": "2025-03-24T17:41:17Z",
              "updatedAt": "2025-03-24T17:41:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOOLtax86P6Txq",
      "title": "Mark this document as obsoleting RFC 9180",
      "url": "https://github.com/hpkewg/hpke/pull/14",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-24T17:44:23Z",
      "updatedAt": "2025-06-09T18:40:33Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "obsolete",
      "headRefOid": "11e28ecc81c4b2e131ca9e62b8cc0b21e9296e9d",
      "closedAt": "2025-06-09T18:40:31Z",
      "mergedAt": "2025-06-09T18:40:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "860d9a8c4b37ea0e224bdb2a6b6a309de04f66cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86hpp9y",
          "commit": {
            "abbreviatedOid": "aeb50a7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-25T01:33:29Z",
          "updatedAt": "2025-03-25T01:33:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOOLtax86RUH6R",
      "title": "Languagetool",
      "url": "https://github.com/hpkewg/hpke/pull/15",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an experimental pull request to see if we can get languagetool running in CI.",
      "createdAt": "2025-04-03T20:30:41Z",
      "updatedAt": "2025-04-10T19:07:07Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "6e0ed184c3c2da40066b6b4eeaf4d4c02863e68e",
      "headRepository": "hpkewg/hpke",
      "headRefName": "languagetool",
      "headRefOid": "074aba5bbea3a0e02cce7b9dbfe2f5fe64cbe39d",
      "closedAt": "2025-04-10T19:07:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOOLtax86ULitL",
      "title": "Allow for single-stage KDFs",
      "url": "https://github.com/hpkewg/hpke/pull/16",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds support for single-stage KDFs, for example, SHAKE or TurboSHAKE.  As [discussed on the CFRG list](https://mailarchive.ietf.org/arch/msg/cfrg/L8sWP0VdrKLKp_MUbgjSqx5ArMw/), these KDFs can make HPKE up to 20% faster.\r\n\r\nI have implemented this change by generally making single-stage and two-stage KDFs parallel.  It would have disturbed less text to treat single-stage KDFs as an add-on / alternative to the base RFC 9180 two-stage KDF definition.  But I think this ends up being a little cleaner.\r\n\r\nThe part I am least confident about is the security considerations.  I added some text to the Domain Separation section that I think is true.  I had no idea what to put in the Input Length Restrictions section, so I just added a TODO.\r\n\r\nFixes #3 ",
      "createdAt": "2025-04-28T14:42:40Z",
      "updatedAt": "2025-06-16T04:05:58Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "79c295bd9c35015d01bdfab5cda85d9da4b9335f",
      "headRepository": "hpkewg/hpke",
      "headRefName": "xof",
      "headRefOid": "15fac25c6cf8b3b148b47f95bfdc93dbf891ec45",
      "closedAt": "2025-06-09T19:38:19Z",
      "mergedAt": "2025-06-09T19:38:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "42e54f04ff8bf2eae0f3654a2ff37ef8b51247bc"
      },
      "comments": [
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "Potential issue: The exporter `derive_input` does not include the output length. This causes shorter exporter outputs to be prefixes of longer exporter outputs, which is never the case in RFC9180, if the KDF Derive acts as XOF (e.g., (Turbo)SHAKE).\r\n\r\nI checked all the uses of Derive(), this is the only use that is potentially affected by Derive() being a XOF.",
          "createdAt": "2025-04-28T17:04:42Z",
          "updatedAt": "2025-04-28T17:04:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point @ilaril.  The most recent PR includes the length in `LabeledDerive()`.  Seems like that addresses the issue?",
          "createdAt": "2025-04-28T17:10:32Z",
          "updatedAt": "2025-04-28T17:10:32Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "Yes, it does address the issue (even if exporter is the only thing that needs it). ",
          "createdAt": "2025-04-28T17:15:55Z",
          "updatedAt": "2025-04-28T17:15:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I just put it there because it seemed cheap and conservative.",
          "createdAt": "2025-04-28T17:24:16Z",
          "updatedAt": "2025-04-28T17:24:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@ilaril - Since it seemed more compatible with SP800-56C, I re-arranged `LabeledDerive()` so that the secret and non-secret inputs are separate, and so that the secrets come first in the derivation.  WDYT?",
          "createdAt": "2025-04-29T22:44:42Z",
          "updatedAt": "2025-04-29T22:44:42Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "In theory, is that strictly injective without the ikm component count?\r\n\r\nIn practice, it is injective, since otherwise would require 18,512 byte KEM output, which is crazy large.\r\n\r\n",
          "createdAt": "2025-04-30T08:08:13Z",
          "updatedAt": "2025-04-30T08:08:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems injective to me, since you could parse it unambiguously.",
          "createdAt": "2025-04-30T13:24:01Z",
          "updatedAt": "2025-04-30T13:24:01Z"
        },
        {
          "author": "ilaril",
          "authorAssociation": "NONE",
          "body": "I was thinking of trying to parse \"sec\" (exporter) labeled_ikm as \"secret\" (main KDF) labeled_ikm.\r\n\r\nThe exporter secret gets parsed as psk. Then it goes to parse the magic as 18,512 byte shared secret, which causes the parsing to desync. And it looks like it is theoretically possible for things to resync in the end.\r\n\r\nOf course, this will never happen in practice, because no KEM has output of that size, and it is extremely unlikely for KEM output to have valid magic (there are at least 17 fixed bytes in play).",
          "createdAt": "2025-04-30T16:14:53Z",
          "updatedAt": "2025-04-30T16:14:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2025-06-06:\r\n* Add note about length restriction\r\n* Then clear to merge",
          "createdAt": "2025-06-06T16:18:15Z",
          "updatedAt": "2025-06-06T16:18:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Action to add a note about the length restrictions on inputs, imposed by the `lengthPrefixed()` function used for various fields.  (Down from ~2^61 previously)",
          "createdAt": "2025-06-06T16:18:22Z",
          "updatedAt": "2025-06-06T16:18:22Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I'd prefer we didn't have the same names for single-stage. This makes it easier for implementors to map directly from the RFC to their public API. Because when implementors add single-stage, they're going to have to pick a name on their own if their language doesn't have overloading. It would be good to have a \"hint\" for them to just use, if possible.",
          "createdAt": "2025-06-06T16:21:29Z",
          "updatedAt": "2025-06-06T16:21:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> Action to add a note about the length restrictions on inputs, imposed by the `lengthPrefixed()` function used for various fields. (Down from ~2^61 previously)\r\n\r\nActually, this was already in the PR:\r\n\r\n> For one-stage KDFs, there is length limit of 65,535 bytes for the `psk`,\r\n> `psk_id`, `info` fields. This limitation arises because these fields are all\r\n> prefixed with a two-byte length when being used as KDF inputs.",
          "createdAt": "2025-06-09T19:11:28Z",
          "updatedAt": "2025-06-09T19:11:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86m3u4X",
          "commit": {
            "abbreviatedOid": "64d308c"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-28T14:59:16Z",
          "updatedAt": "2025-04-28T14:59:16Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "No equivalent of `dkp_prk`",
              "createdAt": "2025-04-28T14:59:16Z",
              "updatedAt": "2025-04-28T14:59:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86m3vVI",
          "commit": {
            "abbreviatedOid": "64d308c"
          },
          "author": "bwesterb",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-28T14:59:49Z",
          "updatedAt": "2025-04-28T14:59:49Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Is that an isuse?",
              "createdAt": "2025-04-28T14:59:49Z",
              "updatedAt": "2025-04-28T14:59:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86m56sn",
          "commit": {
            "abbreviatedOid": "2f7b5a2"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-28T18:01:39Z",
          "updatedAt": "2025-04-28T18:01:40Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "What is `shared_secret`? It does not seem to be (implicit) parameter to `ExtractAndExpand()`, and looking at the code, using the function, looks like shared_secret is the output of it.",
              "createdAt": "2025-04-28T18:01:40Z",
              "updatedAt": "2025-04-28T18:01:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86m4HSH",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-28T15:24:21Z",
          "updatedAt": "2025-04-28T20:55:03Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Why would it be?  (Honest question.)  It seems like `dkp_prk` is just there because you can't count on `ikm` being suitable as a PRK for `Expand()`.",
              "createdAt": "2025-04-28T15:24:21Z",
              "updatedAt": "2025-04-28T20:55:03Z"
            },
            {
              "originalPosition": 76,
              "body": "I think it's a typo for `kem_context`.",
              "createdAt": "2025-04-28T20:53:48Z",
              "updatedAt": "2025-04-28T20:55:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nAlW2",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T04:33:49Z",
          "updatedAt": "2025-04-29T04:33:49Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Does this need to be in the registry, or is it an implementation detail?",
              "createdAt": "2025-04-29T04:33:49Z",
              "updatedAt": "2025-04-29T04:33:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nAmAm",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T04:36:46Z",
          "updatedAt": "2025-04-29T04:36:46Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I would split this up with separate code blocks for two-stage and one-stage KDFs.",
              "createdAt": "2025-04-29T04:36:46Z",
              "updatedAt": "2025-04-29T04:36:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nAmfi",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T04:38:59Z",
          "updatedAt": "2025-04-29T04:38:59Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "You are doing the single invocation and slicing of output to avoid overheads, is that right?\r\n\r\nDid you look into doing:\r\n\r\n```\r\nkey = LabeledDerive(derive_input, \"key\", Nk)\r\nbase_nonce = LabeledDerive(derive_input, \"base_nonce\", Nn)\r\nexporter_secret = LabeledDerive(derive_input, \"exp\", Nh)\r\n```\r\n?\r\n\r\nThe reason I say that is that you are pulling in a lot of additional context into your two- vs. one-stage branch.  The structure above (with appropriate caching) allows you to make the split much closer to the KDF functions (mostly, the whole extraction business in two-stage seems needlessly complex).",
              "createdAt": "2025-04-29T04:38:59Z",
              "updatedAt": "2025-04-29T04:42:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nBkaD",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T06:38:00Z",
          "updatedAt": "2025-04-29T06:38:00Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Yes, the hpke-bench did look at structure like that. It is ~30% overhead for the main KDF, even with optimal caching.\r\n\r\nSingle-invocation (flat) TurboSHAKE was the only option related to SHA-3 that beat hardware-accelerated HKDF-SHA256 in speed (1.7448 versus 2.0896 on Zen4).",
              "createdAt": "2025-04-29T06:38:00Z",
              "updatedAt": "2025-04-29T07:01:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nNEIY",
          "commit": {
            "abbreviatedOid": "aabd724"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-29T22:34:52Z",
          "updatedAt": "2025-04-29T22:34:53Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Fair point, I think we can get away without it.",
              "createdAt": "2025-04-29T22:34:52Z",
              "updatedAt": "2025-04-29T22:34:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nVzcO",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-30T15:33:15Z",
          "updatedAt": "2025-04-30T15:33:15Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "kem_context does not seem like a secret value (seems to contain the public keys)?\r\n\r\nSo presumably it should be applied as context to LabeledDerive()?",
              "createdAt": "2025-04-30T15:33:15Z",
              "updatedAt": "2025-04-30T15:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nV7s0",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-30T15:42:57Z",
          "updatedAt": "2025-04-30T15:42:57Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "Seems like psk, psk_id, info and ikm are limited to 65535 bytes (since length is 2 bytes) for single-stage KDFs. ~~Exporter_context has no explicit limit, but may be limited by total Derive() input length. For underlying constructs related to SHA-3, there are no limits on exporter_context.~~ Missed that LabeledDerive() actually length-prefixes the context (I do not think this is a good idea), which also limits the exporter_context to 65535 bytes. And seemingly also imposes joint limit of 65530 bytes for psk_id and info.\r\n\r\nThen section \"Secret Export\" (I do not think I can directly comment on it) contains this text: \"For the KDFs defined in this specification, L has a maximum value of 255*Nh. Future specifications that define new KDFs MUST specify a bound for L.\"... Single-stage KDFs have limit of 4294967295 for L (since length field is 4 bytes).",
              "createdAt": "2025-04-30T15:42:57Z",
              "updatedAt": "2025-04-30T16:29:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nWZVV",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-30T16:21:01Z",
          "updatedAt": "2025-04-30T16:21:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think length-prefixing context is not a good idea. No current use needs the length, and it could get annoying with things like \"secret\" (the main KDF) that have length-prefixed subfields.",
              "createdAt": "2025-04-30T16:21:01Z",
              "updatedAt": "2025-04-30T16:21:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86na5td",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-04-30T23:58:40Z",
          "updatedAt": "2025-04-30T23:58:40Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "What if you have (label = \"foo\", context = \"bar\") for one usage and (label = \"foobar\", context = \"\") in another.  Those a distinct, but without a length prefix, they would collide.  Don't we have to have something to prevent them spilling over?",
              "createdAt": "2025-04-30T23:58:40Z",
              "updatedAt": "2025-04-30T23:58:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86ncTzP",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T06:07:43Z",
          "updatedAt": "2025-05-01T06:07:43Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "The label is length prefixed, so label=\"foo\", context=\"bar\" would encode to \"\\x00\\x03foobar\", and label=\"foobar\", context=\"\" would encode to \"\\x00\\x06foobar\". Which do not collide.\r\n\r\nSimilarly, if one used FF-terminated UTF-8 for labels, label=\"foo\", context=\"bar\" gives \"foo\\xffbar\", and label=\"foobar\", context=\"\" gives \"foobar\\xff\", which are again different.",
              "createdAt": "2025-05-01T06:07:43Z",
              "updatedAt": "2025-05-01T06:11:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86ncYuq",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T06:34:33Z",
          "updatedAt": "2025-05-01T06:34:33Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I see, you were only talking about `context` being prefixed.  That conflicts with the value of `L` that follows, doesn't it?  Or are you suggesting that the length of the KDF input being different is sufficient?  That seems like too negligible of an optimization to be worth it to me.",
              "createdAt": "2025-05-01T06:34:33Z",
              "updatedAt": "2025-05-01T06:34:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86nfXMI",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "ilaril",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-01T15:19:14Z",
          "updatedAt": "2025-05-01T15:19:14Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Removing that length would not just be an optimization, because it causes joint limit for psk_id and info. Which is something no existing KDF has, and looking at RFC 9180 Section 7.2.1, no HPKE KDF is envisioned to have.\r\n\r\nAnd copying the context into buffer is not good, as it either requires dynamic allocation or having small limits like the recommended 64 byte limit for info and exporter_context from RFC 9180, which have proven to be too small for actual applications. Scatter-gather (avoiding both dynamic allocation and small limits) should be easy to implement.\r\n\r\nAnd on optimizations, I think moving the output length field before the label and making it 2 bytes would be a small optimization. No existing KDF allows exporting more than 16,320 bytes in one shot, and the minmax size is 8,160 bytes. Both fit into 2 byte length field.\r\n\r\n\r\n",
              "createdAt": "2025-05-01T15:19:14Z",
              "updatedAt": "2025-05-01T15:19:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86oQa8j",
          "commit": {
            "abbreviatedOid": "27872f8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-05-07T18:50:23Z",
          "updatedAt": "2025-05-07T18:50:24Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Putting all this together, if we use this construction:\r\n\r\n```\r\n  labeled_ikm = concat(\r\n    ikm,\r\n    \"HPKE_v1\",\r\n    suite_id,\r\n    lengthPrefixed(label),\r\n    I2OSP(L, 2)\r\n    context,\r\n)\r\n```\r\n\r\n... it seems like we tick all the boxes\r\n\r\n* [X] The encoding is injective, since the only indefinite-length value is the last one\r\n* [X] There's no joint limit on `psk_id + info` (though there is on each field individually)",
              "createdAt": "2025-05-07T18:50:23Z",
              "updatedAt": "2025-05-07T18:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLRc2",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:21:09Z",
          "updatedAt": "2025-06-06T16:21:10Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Is it possible to distinguish these with different names? They have the same function signature? Or maybe some magic about an interface or template ",
              "createdAt": "2025-06-06T16:21:09Z",
              "updatedAt": "2025-06-06T16:21:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLR0-",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "richsalz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:21:53Z",
          "updatedAt": "2025-06-06T16:21:53Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "completely agree; we were writing at the same time: https://github.com/hpkewg/hpke/pull/16#issuecomment-2949790941\r\n",
              "createdAt": "2025-06-06T16:21:53Z",
              "updatedAt": "2025-06-06T16:21:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLR0_",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:21:53Z",
          "updatedAt": "2025-06-06T16:21:53Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```\r\n- SingleStage()\r\n- TwoStage()\r\n```",
              "createdAt": "2025-06-06T16:21:53Z",
              "updatedAt": "2025-06-06T16:25:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLSoO",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:23:29Z",
          "updatedAt": "2025-06-06T16:23:30Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "@dconnolly works for me.  In the call sites, I would refer to them as `XStage()`, where `X = 1, 2`.",
              "createdAt": "2025-06-06T16:23:29Z",
              "updatedAt": "2025-06-09T18:46:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLWAH",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "richsalz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:29:55Z",
          "updatedAt": "2025-06-06T16:29:55Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Don't change the names of the existing methods.  Add an alias if you must.",
              "createdAt": "2025-06-06T16:29:55Z",
              "updatedAt": "2025-06-06T16:29:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tLjgA",
          "commit": {
            "abbreviatedOid": "64dafd8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-06T16:49:14Z",
          "updatedAt": "2025-06-06T16:49:14Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I would suggest something like:\r\n\r\n```python\r\nif usingSingleStageKDF():\r\n    foo = ExtractExpandOneStage(...)\r\nelse\r\n    foo = ExtractExpandTwoStage(...)\r\n```",
              "createdAt": "2025-06-06T16:49:14Z",
              "updatedAt": "2025-06-06T16:49:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tgyc2",
          "commit": {
            "abbreviatedOid": "74a4f32"
          },
          "author": "richsalz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-09T19:11:19Z",
          "updatedAt": "2025-06-09T19:11:19Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Are we defining an API?  Perhaps say \"for clarity in this document, the definition and use of such functions will have suffixes ...\"",
              "createdAt": "2025-06-09T19:11:19Z",
              "updatedAt": "2025-06-09T19:11:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86tg1qW",
          "commit": {
            "abbreviatedOid": "74a4f32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-09T19:15:58Z",
          "updatedAt": "2025-06-09T19:15:58Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Reworded.",
              "createdAt": "2025-06-09T19:15:58Z",
              "updatedAt": "2025-06-09T19:15:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOOLtax86urQTz",
          "commit": {
            "abbreviatedOid": "15fac25"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-06-16T04:05:58Z",
          "updatedAt": "2025-06-16T04:05:58Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Missing a colon here. I think.",
              "createdAt": "2025-06-16T04:05:58Z",
              "updatedAt": "2025-06-16T04:05:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOOLtax86Ygo4O",
      "title": "Reflect WG adoption",
      "url": "https://github.com/hpkewg/hpke/pull/18",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-06-01T22:07:29Z",
      "updatedAt": "2025-06-01T23:03:41Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "6e0ed184c3c2da40066b6b4eeaf4d4c02863e68e",
      "headRepository": "hpkewg/hpke",
      "headRefName": "adopt",
      "headRefOid": "66b8c594870a9e2104d1d7ac1d9d77a2a50c99f6",
      "closedAt": "2025-06-01T23:03:41Z",
      "mergedAt": "2025-06-01T23:03:41Z",
      "mergedBy": "yaroslavros",
      "mergeCommit": {
        "oid": "9bfd25388626e0541d88f00a2680e1214563b2a3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOOLtax86Zaewq",
      "title": "Remove the Auth modes",
      "url": "https://github.com/hpkewg/hpke/pull/19",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1 \r\n\r\nMarked as WIP because the test vectors for these modes still need removing.",
      "createdAt": "2025-06-06T15:58:37Z",
      "updatedAt": "2025-06-24T01:49:36Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "860d9a8c4b37ea0e224bdb2a6b6a309de04f66cf",
      "headRepository": "hpkewg/hpke",
      "headRefName": "no-auth",
      "headRefOid": "415677c226e4156718388ee1c17814e86d1bc8a9",
      "closedAt": "2025-06-24T01:49:36Z",
      "mergedAt": "2025-06-24T01:49:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "02c5ceb535bac6925e441af5f1972cafaf09545b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOOLtax86thaze",
          "commit": {
            "abbreviatedOid": "415677c"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-06-09T20:08:38Z",
          "updatedAt": "2025-06-09T20:08:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "PR_kwDOOLtax86b6mQx",
      "title": "Add operational considerations about configuration and API design",
      "url": "https://github.com/hpkewg/hpke/pull/24",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23 ",
      "createdAt": "2025-06-24T18:23:02Z",
      "updatedAt": "2025-06-28T16:11:59Z",
      "baseRepository": "hpkewg/hpke",
      "baseRefName": "main",
      "baseRefOid": "02c5ceb535bac6925e441af5f1972cafaf09545b",
      "headRepository": "hpkewg/hpke",
      "headRefName": "algs",
      "headRefOid": "a73cd01c8233eb8ab08be2607c1007cff25729f1",
      "closedAt": "2025-06-28T16:11:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Turns out there's no issue here.\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/hpke/BDKsmqSb9cDPUsb-VZlRu6FZMW0/",
          "createdAt": "2025-06-28T16:11:59Z",
          "updatedAt": "2025-06-28T16:11:59Z"
        }
      ],
      "reviews": []
    }
  ]
}